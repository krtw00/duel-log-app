# 設計原則

Duel Log Appの6つの中核となる設計原則。すべての機能・実装はこれらの原則に従います。

---

## 原則一覧

1. **User-Centric Simplicity**
2. **Privacy First**
3. **Layered Architecture**
4. **Type Safety**
5. **Single Source of Truth**
6. **Progressive Enhancement**

---

## 1. User-Centric Simplicity

### 原則

**ユーザーの対戦記録・分析をシンプルかつ直感的に行えるようにする。**

複雑な設定や操作を排除し、最小限の操作で目的を達成できるUIを提供する。

### 理由

- **学習コストの低減**: 初めてのユーザーでも迷わない
- **継続利用**: 日々の記録が苦にならない
- **本質への集中**: 統計分析という本来の価値に集中

### 実践例

```
┌─────────────────────────────────────────────────────────────────┐
│  対戦記録フロー                                                 │
│                                                                 │
│  ❌ 悪い例: 設定 → デッキ選択 → 対戦相手入力 → 詳細設定 → 確認  │
│                                                                 │
│  ✅ 良い例: デッキ選択 → 勝敗クリック → 完了                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### チェックポイント

- [ ] 3クリック以内で主要操作が完了するか？
- [ ] 初めてのユーザーでも説明なしで使えるか？
- [ ] 不要な確認ダイアログを表示していないか？

---

## 2. Privacy First

### 原則

**ユーザーのプライバシーを最優先で保護する。特に配信者のプライバシーに配慮する。**

配信者モード、共有設定、データアクセス制御を通じてプライバシーを守る。

### 理由

- **配信者保護**: 配信中に個人情報が漏れない
- **ユーザー信頼**: データの取り扱いに対する信頼
- **法的コンプライアンス**: GDPR等の規制対応

### 実践例

```
┌─────────────────────────────────────────────────────────────────┐
│  配信者モード                                                   │
│                                                                 │
│  ON状態:                                                        │
│  - ユーザー名: ●●●●●（マスク表示）                            │
│  - メールアドレス: 非表示                                       │
│  - 対戦相手名: 匿名化オプション                                 │
│                                                                 │
│  統計共有:                                                      │
│  - 共有したいデータのみ選択可能                                 │
│  - いつでも共有を停止可能                                       │
└─────────────────────────────────────────────────────────────────┘
```

### チェックポイント

- [ ] 認証なしでアクセス可能なデータは意図的に公開されたものだけか？
- [ ] 配信者モードで個人情報が露出しないか？
- [ ] データ削除機能が提供されているか？

---

## 3. Layered Architecture

### 原則

**責務を明確に分離したレイヤー構成を維持する。**

バックエンドはRouter → Service → Model、フロントエンドはView → Composable → Store → API。

### 理由

- **テスト容易性**: 各レイヤーを独立してテスト可能
- **保守性**: 変更の影響範囲を限定
- **再利用性**: ロジックの再利用

### バックエンドレイヤー

```
┌─────────────────────────────────────────────────────────────────┐
│  バックエンド                                                   │
│                                                                 │
│  Router (api/routers/)                                          │
│    - HTTPリクエスト/レスポンス処理                              │
│    - バリデーション                                             │
│    ↓                                                            │
│  Service (services/)                                            │
│    - ビジネスロジック                                           │
│    - トランザクション管理                                       │
│    ↓                                                            │
│  Model (models/)                                                │
│    - SQLAlchemyモデル                                           │
│    - データアクセス                                             │
└─────────────────────────────────────────────────────────────────┘
```

### フロントエンドレイヤー

```
┌─────────────────────────────────────────────────────────────────┐
│  フロントエンド                                                 │
│                                                                 │
│  View (views/)                                                  │
│    - 画面構成、レイアウト                                       │
│    ↓                                                            │
│  Component (components/)                                        │
│    - 再利用可能なUI部品                                         │
│    ↓                                                            │
│  Composable (composables/)                                      │
│    - 再利用可能なロジック                                       │
│    ↓                                                            │
│  Store (stores/)                                                │
│    - グローバル状態管理（Pinia）                                │
│    ↓                                                            │
│  API Client (services/api.ts)                                   │
│    - バックエンドとの通信                                       │
└─────────────────────────────────────────────────────────────────┘
```

### チェックポイント

- [ ] RouterにビジネスロジックがないかA
- [ ] ServiceがHTTPの概念（status code等）を知らないか？
- [ ] ComponentがAPIを直接呼んでいないか？

---

## 4. Type Safety

### 原則

**TypeScript/Pythonの型システムを最大限活用し、実行時エラーをコンパイル時に検出する。**

any型の使用を避け、strictモードを有効にする。

### 理由

- **バグの早期発見**: コンパイル時にエラー検出
- **ドキュメント効果**: 型がドキュメントとして機能
- **リファクタリング安全性**: 型チェックでリグレッション防止

### 実践例

```typescript
// ❌ 悪い例
const processData = (data: any) => { ... }

// ✅ 良い例
interface DuelRecord {
  id: string
  result: 'win' | 'lose' | 'draw'
  deckId: string
  opponentDeckId: string
  createdAt: Date
}

const processData = (data: DuelRecord) => { ... }
```

```python
# ❌ 悪い例
def create_duel(data: dict) -> dict:
    ...

# ✅ 良い例
def create_duel(data: DuelCreate) -> DuelResponse:
    ...
```

### チェックポイント

- [ ] any型を使用していないか？
- [ ] 戻り値の型が明示されているか？
- [ ] Optional型が適切に使用されているか？

---

## 5. Single Source of Truth

### 原則

**データの真実は一箇所（データベース）のみとする。**

フロントエンドの状態はバックエンドのキャッシュであり、競合時はバックエンドが優先。

### 理由

- **データ整合性**: 複数箇所に同じデータを持たない
- **シンプルな同期**: 常にバックエンドから最新を取得
- **デバッグ容易性**: データの出処が明確

### データフロー

```
┌─────────────────────────────────────────────────────────────────┐
│  Single Source of Truth                                         │
│                                                                 │
│  Frontend (Pinia Store)                                         │
│    - バックエンドのキャッシュ                                   │
│    - 楽観的更新は最小限                                         │
│    ↓↑                                                           │
│  Backend (FastAPI)                                              │
│    - バリデーション、ビジネスロジック                           │
│    ↓↑                                                           │
│  Database (PostgreSQL) ← Single Source of Truth                 │
│    - データの真実                                               │
└─────────────────────────────────────────────────────────────────┘
```

### チェックポイント

- [ ] フロントエンドで独自に計算した値をバックエンドに送っていないか？
- [ ] 更新後に最新データをバックエンドから取得しているか？
- [ ] ローカルストレージにデータを永続化していないか？（設定を除く）

---

## 6. Progressive Enhancement

### 原則

**基本機能を優先し、拡張機能は段階的に追加する。**

コア機能（対戦記録・統計表示）を堅牢に保ち、付加機能（AI分析等）は後から追加。

### 理由

- **早期リリース**: 最小限の機能で早くリリース
- **ユーザーフィードバック**: 実際の使用から学ぶ
- **リスク分散**: 大きな変更を小さく分割

### 優先度

```
┌─────────────────────────────────────────────────────────────────┐
│  機能優先度                                                     │
│                                                                 │
│  P0 (必須): 対戦記録、基本統計、認証                            │
│    ↓                                                            │
│  P1 (重要): デッキ相性表、OBSオーバーレイ、統計共有             │
│    ↓                                                            │
│  P2 (あると良い): 管理者画面、CSVインポート/エクスポート        │
│    ↓                                                            │
│  P3 (将来): AI分析、多言語対応、モバイルアプリ                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### チェックポイント

- [ ] 新機能がコア機能を複雑にしていないか？
- [ ] フィーチャーフラグで新機能を制御できるか？
- [ ] 新機能が壊れてもコア機能は動作するか？

---

## 原則間の関係

これら6つの原則は互いに補完し合います：

```
User-Centric Simplicity ──→ ユーザー体験の最適化
         ↓
Privacy First ───────────→ 信頼の確保
         ↓
Layered Architecture ────→ 保守性・テスト容易性
         ↓
Type Safety ─────────────→ 品質保証
         ↓
Single Source of Truth ──→ データ整合性
         ↓
Progressive Enhancement ─→ 持続可能な開発
```

---

## 設計決定の確認

新しい機能を追加・設計する際は、これら6原則に照らし合わせて確認してください：

- [ ] User-Centric Simplicityか？（シンプルな操作）
- [ ] Privacy Firstか？（プライバシー保護）
- [ ] Layered Architectureか？（レイヤー分離）
- [ ] Type Safetyか？（型安全）
- [ ] Single Source of Truthか？（データの真実は一箇所）
- [ ] Progressive Enhancementか？（段階的追加）

---

## 関連ドキュメント

- @./error-handling.md - エラーハンドリングパターン
- @./code-readability-guide.md - コード品質基準
- @../10-decisions/ - アーキテクチャ決定記録（ADR）
- @../02-architecture/backend-architecture.md - バックエンド構造
- @../02-architecture/frontend-architecture.md - フロントエンド構造
