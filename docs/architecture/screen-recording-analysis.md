# 画面録画からのイベント抽出（選択権検出・勝敗判定）設計

このドキュメントは、ブラウザの画面録画（ユーザーが共有したタブ/画面）から、対戦中の特定シーンを検出し、Duel Log Appに「イベント」として取り込むための設計をまとめます。

対象は以下です。

- **先攻/後攻の選択権がある画面の検出**（※先攻後攻の“結果”は推定しない）
- **勝敗（`VICTORY` / `LOSE`）の判定**

---

## 1. 前提と要件

### 1.1 前提

- PC利用が基本、解像度は `1280×720` 〜 `3840×2160`
- 画面比率は **16:9**（前提が崩れる場合は別途対応が必要）
- UIは固定で、勝敗文字（`VICTORY` / `LOSE`）の位置・大きさは実質固定
- ブラウザの画面録画を **プレビュー表示せず**、裏側（Worker）で処理する
- UI変更は可能だが、可能な限り最小にしたい

### 1.2 非目標（スコープ外）

- 対戦アプリ内部の状態（デッキ内容、カード名等）をOCRで読む
- 先攻/後攻の最終結果（誰が先攻になったか）を映像から推定する

---

## 2. 全体アーキテクチャ（推奨）

映像解析は「**フレーム取得 → 正規化 → ROI抽出 → 画像特徴化 → テンプレ一致 → 時系列確定（FSM）**」のパイプラインで実装します。

### 2.1 フレーム取得（ブラウザ）

- `getDisplayMedia()` で共有映像を取得（ユーザー操作で許可が必要）
- `MediaStreamTrackProcessor`（WebCodecs）で `VideoFrame` を取り出し
- `Worker` + `OffscreenCanvas` に描画して解析（UIスレッド負荷を最小化）

注意:

- 共有中インジケータ等、OS/ブラウザ由来の表示は消せません。
- DRM/保護コンテンツ等は取得できない場合があります（黒塗りや無信号になることがあります）。

### 2.2 解析フレームレート

常時高fpsで解析すると負荷が大きいため、以下の運用を推奨します。

- 通常スキャン: **2〜5 fps**
- 重要シーン候補が出たとき（勝敗/選択権の一致が閾値付近）: **10〜15 fps**へ一時引き上げ

### 2.3 プライバシー/データ取り扱い

- 解析は可能な限り **クライアント（ブラウザ）内で完結**させ、フレーム画像をサーバーへ送らない
- 保存が必要な場合も、デフォルトは「イベント（勝敗/選択権）とメタ情報」のみを保存し、画像の永続化はオプトインにする

---

## 3. 解像度差に強い「正規化」方針

テンプレ一致を安定させるため、入力フレームを毎回 **固定幅へリサイズ**してから処理します。

- 正規化解像度: **幅 1280px**（高さは16:9で自動的に720px相当）
- 以降のROI座標は **`1280×720`基準**で定義する

この正規化により、テンプレをマルチスケールで探索する必要がほぼ無くなり、精度と速度が両立します。

---

## 4. 検出対象A: 「先攻/後攻を選択してください」画面（選択権あり）

### 4.1 目的

- 当該画面を検出したら、アプリ側で「この試合は **先攻（デフォルト）**」を暫定確定する
- ユーザーがオプションの「後攻に切替」ボタンを押した場合、**後攻に上書き確定**する
- 画面が消えたらロックして以降は変更不可（誤操作防止）

### 4.2 検出方法（テンプレ / ハッシュ）

UIが固定であるため、学習モデルよりも **テンプレ一致**が最小実装で堅牢です。

推奨は次のいずれか（併用も可）。

- **テンプレマッチ（NCC / SSIM）**: メッセージ帯ROIをテンプレと照合
- **pHash（知覚ハッシュ）**: ROIを縮小してハッシュ化し、ハミング距離で判定

### 4.3 ROI（推奨）

添付の例では、中央のメッセージ帯が安定しているため、そこだけを見ます（正規化後）。

- `TurnChoiceROI`（候補）: `x=256..1024`, `y=375..500`
- まずは広めに取り、誤差が無ければ後で絞る

### 4.4 確定ロジック（デバウンス）

1フレームで確定せず、連続一致で確定します。

- `score >= threshold` を **3フレーム連続**で満たしたら `TurnChoiceAvailable` とする
- 確定後、当該画面が **一定時間見えなくなった**らロック

---

## 5. 検出対象B: 勝敗（`VICTORY` / `LOSE`）

### 5.1 検出方法（前処理 + テンプレ一致）

背景が動く/ブラーがあるため、テンプレは“生画像”よりもエッジ化が安定します。

推奨前処理:

1. グレースケール化
2. 低強度ブラー（例: Gaussian）
3. Canny等でエッジ抽出

上記を **ROIとテンプレ両方**に適用し、テンプレマッチ（NCC系）を取ります。

### 5.2 ROI（推奨）

`VICTORY/LOSE` は画面中央・上寄りに固定で出るため、正規化後に固定切り出しします。

- `ResultTextROI`（候補）: `x=80..1200`, `y=70..390`

この範囲は少し広めです。テンプレマッチで位置合わせされるため、多少の揺れやブラーに強くなります。

### 5.3 確定ロジック（多数決 + クールダウン）

- `winScore` と `loseScore` を毎フレーム算出
- `max(winScore, loseScore) >= threshold` かつ `|winScore - loseScore| >= margin` を満たすフレームを「有効票」とする
- **5フレーム中3フレーム**で同じ勝敗なら確定
- 確定後は **8〜15秒**のクールダウンを入れて二重計上を防止

補強（任意）:

- リザルト時に表示される `OK` ボタン領域もテンプレ検出し、`OK` が見えている場合のみ勝敗判定を有効化する

---

## 6. FSM（時系列の確定・誤検出抑制）

検出は画像1枚で完結させず、状態機械で「いつの判定か」を管理します。

推奨状態:

- `Idle`
- `TurnChoiceAvailable`（選択権あり）
- `TurnChoiceLocked`（確定・変更不可）
- `ResultDetected(win|lose)`（勝敗確定）
- `Cooldown`（二重計上防止）

主要ルール例:

- `ResultDetected` は `Cooldown` 中は無効
- `TurnChoiceAvailable` 中のみ UI に「後攻に切替」を出す
- `TurnChoiceLocked` 以降は変更不可

---

## 7. UIへの落とし込み（最小変更）

### 7.1 推奨UI（最小）

- 「解析中」状態表示（任意、通常は非表示）
- `TurnChoiceAvailable` の間だけ表示される:
  - ボタン: **「後攻に切替」**
  - ショートカット（任意）: `T`

### 7.2 取り込みイベント（例）

- `turnChoiceAvailable`（時刻、信頼度）
- `turnChoiceSelected`（`first` / `second`、確定時刻）
- `resultDetected`（`win` / `lose`、信頼度、確定時刻）

---

## 8. テンプレート管理とマルチ解像度対応

### 8.1 基本方針: 単一の高品質テンプレート

プロジェクトで管理するテンプレート画像は、リソースの管理を簡素化するため、各種類（例: `result-win`）につき**1枚のみ**とします。

この1枚は、想定される**最も高い品質（例: 3840x2160 / 4K）**でキャプチャした、非常にクリアなマスター画像とします。

### 8.2 設計: MIPMAPアプローチによる動的テンプレート生成

単一のマスターテンプレートで複数の入力品質（解像度）に頑健に対応するため、3DグラフィックスのMIPMAP（ミップマップ）に近いアプローチを採用します。

#### 8.2.1 起動時のテンプレートキャッシュ生成

1.  **マスター読込**: アプリケーション起動時（または解析機能の初期化時）に、`public/screen-analysis/`に配置された単一の高品質マスターテンプレート（例: `result-win.png`）を読み込みます。
2.  **動的リサイズとキャッシュ**: 読み込んだマスター画像から、対応したい主要な解像度（例: 720p, 1080p, 1440p, 2160p）に合わせたテンプレート群を**動的にリサイズ生成**します。
3.  **前処理とキャッシュ**: 生成した各解像度のテンプレートに、それぞれエッジ抽出などの前処理を施し、すぐに利用できる形でメモリ上にキャッシュ（一時保管）します。

#### 8.2.2 解析時のインテリジェントなテンプレート選択

1.  **解像度判定**: ユーザーの画面共有ストリームから取得した映像の実際の解像度（例: `1920x1080`）を判定します。
2.  **最適テンプレート選択**: 判定した解像度に**最も近いテンプレート**を、メモリ上のキャッシュから選択します。
    -   入力が `1920x1080` (1080p) なら → `1080p版`のテンプレートを選択
    -   入力が `1280x720` (720p) なら → `720p版`のテンプレートを選択
3.  **マッチング実行**: 選択したテンプレートと入力画像を比較します。これにより、両者の品質（解像度）がほぼ同一となり、安定したマッチングスコアが期待できます。

#### 8.2.3 実装フロー図

```
(単一の高品質マスターテンプレート.png)
             |
      [初期化処理]
             |
  +----------------------+
  |  動的リサイズと前処理  |
  +----------------------+
             |
+-------------------------------------------+
|        メモリ上のテンプレートキャッシュ        |
| {                                         |
|   "720p":  <前処理済みの720p版データ>,    |
|   "1080p": <前処理済みの1080p版データ>,   |
|   "1440p": <前処理済みの1440p版データ>    |
| }                                         |
+-------------------------------------------+
               |
[解析ループ] <--- (現在のフレーム解像度: 1080p)
               |
    (キャッシュから1080p版データを選択して使用)
```

### 8.3 メリット

-   **管理の容易さ**: プロジェクトリソースとして管理する画像ファイルは、各種類1枚だけで済みます。
-   **高いマッチング精度**: 入力映像とテンプレートの品質のミスマッチを防ぎ、あらゆる解像度で安定した解析精度を実現します。
-   **将来の拡張性**: 将来的に新しい解像度に対応する場合でも、起動時に生成するキャッシュのパターンを追加するだけで済み、マスター画像を再作成する必要はありません。

---

## 付録: 実装メモ（ライブラリ選定）

- 画像処理（テンプレマッチ/Canny等）をそのまま使いたい場合: `OpenCV.js`
- 依存を最小にしたい場合: 最低限の前処理（グレースケール/縮小/pHash）+ 自前のNCC実装でも成立

---

## 9. 評価とチューニング指針

最低限、以下をログで可視化すると調整が早くなります。

- `winScore/loseScore` の時系列（ピークが出ているか）
- `TurnChoice` のスコア推移と確定タイミング
- FSMの状態遷移ログ（誤検出時の原因追跡）

まずは閾値を高めに置き、取りこぼしが出たらROIと前処理（ブラー強度、Canny閾値）を調整します。
