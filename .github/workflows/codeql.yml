name: "CodeQL"

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # æ¯é€±æœˆæ›œæ—¥ 9:00 UTC (18:00 JST) ã«å®Ÿè¡Œ
    - cron: '0 9 * * 1'

jobs:
  analyze:
    name: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ†æ
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
      pull-requests: write

    strategy:
      fail-fast: false
      matrix:
        language: [ 'python', 'javascript' ]

    steps:
      - name: ãƒªãƒã‚¸ãƒˆãƒªã‚’ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
        uses: actions/checkout@v5

      - name: CodeQLã‚’åˆæœŸåŒ–
        uses: github/codeql-action/init@v4
        with:
          languages: ${{ matrix.language }}
          queries: security-extended,security-and-quality

      - name: è‡ªå‹•ãƒ“ãƒ«ãƒ‰
        uses: github/codeql-action/autobuild@v4

      - name: CodeQLåˆ†æã‚’å®Ÿè¡Œ
        id: codeql-analyze
        uses: github/codeql-action/analyze@v4
        with:
          category: "/language:${{matrix.language}}"
          output: sarif-results
          upload: false

      - name: SARIFçµæœã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
        if: ${{ always() && steps.codeql-analyze.outcome == 'success' && hashFiles(format('sarif-results/{0}.sarif', matrix.language)) != '' }}
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: sarif-results/${{ matrix.language }}.sarif

      - name: CodeQLçµæœã‚’PRã«ã‚³ãƒ¡ãƒ³ãƒˆ
        uses: actions/github-script@v8
        if: github.event_name == 'pull_request' && always()
        continue-on-error: true
        env:
          SARIF_OUTPUT_DIR: sarif-results
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const language = '${{ matrix.language }}';

            // SARIFçµæœãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™
            const candidateDirs = [
              process.env.SARIF_OUTPUT_DIR,
              process.env.CODEQL_ACTION_SARIF_RESULTS_OUTPUT_DIR,
              '.',
            ].filter(Boolean);

            let sarifFiles = [];

            for (const dir of candidateDirs) {
              if (!fs.existsSync(dir) || !fs.statSync(dir).isDirectory()) {
                continue;
              }

              const files = fs
                .readdirSync(dir)
                .filter(name => name.endsWith('.sarif'))
                .map(name => path.join(dir, name));

              if (files.length > 0) {
                sarifFiles = files;
                break;
              }
            }

            if (sarifFiles.length === 0) {
              console.log('SARIFçµæœãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
              return;
            }

            let totalIssues = 0;
            let criticalCount = 0;
            let highCount = 0;
            let mediumCount = 0;
            let lowCount = 0;

            for (const sarifFile of sarifFiles) {
              const sarif = JSON.parse(fs.readFileSync(sarifFile, 'utf8'));

              for (const run of sarif.runs || []) {
                const results = run.results || [];
                totalIssues += results.length;

                for (const result of results) {
                  const level = result.level || 'note';
                  if (level === 'error') criticalCount++;
                  else if (level === 'warning') highCount++;
                  else if (level === 'note') mediumCount++;
                  else lowCount++;
                }
              }
            }

            const languageNames = {
              'python': 'Python',
              'javascript': 'JavaScript/TypeScript'
            };

            let comment = `## ğŸ”’ CodeQLã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ†æçµæœ (${languageNames[language] || language})\n\n`;

            if (totalIssues === 0) {
              comment += `âœ… **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®å•é¡Œã¯æ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ**\n\n`;
              comment += `ã™ã¹ã¦ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ã‚’ãƒ‘ã‚¹ã—ã¾ã—ãŸã€‚\n`;
            } else {
              comment += `âš ï¸ **${totalIssues}å€‹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®å•é¡ŒãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ**\n\n`;
              comment += `### é‡è¦åº¦åˆ¥ã®å†…è¨³:\n`;
              if (criticalCount > 0) comment += `- ğŸ”´ **é‡å¤§**: ${criticalCount}å€‹\n`;
              if (highCount > 0) comment += `- ğŸŸ  **é«˜**: ${highCount}å€‹\n`;
              if (mediumCount > 0) comment += `- ğŸŸ¡ **ä¸­**: ${mediumCount}å€‹\n`;
              if (lowCount > 0) comment += `- ğŸŸ¢ **ä½**: ${lowCount}å€‹\n`;
              comment += `\n`;
              comment += `è©³ç´°ã¯Securityã‚¿ãƒ–ã§ç¢ºèªã—ã¦ãã ã•ã„: [Security â†’ Code scanning alerts](${context.payload.repository.html_url}/security/code-scanning)\n`;
            }

            comment += `\n*CodeQLã«ã‚ˆã‚‹è‡ªå‹•ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³*`;

            // æ—¢å­˜ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ¤œç´¢
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' &&
              c.body.includes(`CodeQLã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ†æçµæœ (${languageNames[language] || language})`)
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }
